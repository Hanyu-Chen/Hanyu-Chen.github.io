---
layout:     post
title:      LeetCode刷题总结（1～50）
subtitle:   记录LC二刷过程，便于复习
date:       2021-01-02
author:     Hanyu Chen
header-img: img/post-bg-debug.png
catalog: true
tags:
    - LeetCode
---

## 1. Two Sum

> 数据结构: HashMap

梦开始的地方。很常规的一道题，直接用HashMap将列表索引和值对应存起来。之后再遍历一次寻找两数。

**注意点：遍历寻找时要将自身排除**

## 15. Three Sum

> 方法: HashMap, 双指针

暴力解法 $O(n^3)$ ，有两种 $O(n^2)$ 解法：

解法一：将所有数两两相加，存在一个HashMap中，其中key为相加后的值，value为两数的列表（因为可能有很多种两数相加后等于同一个值）。之后再遍历一次寻找。时间$O(n^2)$，空间$O(n^2)$

解法二：双指针。详情见伪代码：
```java
for (int i = 0; i < len; ++i) {
  // 用三个变量存：curr(当前值)；left(curr后一个值)；right(列表最后一个值)
  // 如果当前值 > 0，直接break
  while (left < right) {
    // 如果curr+left+right < 0，left右移一位；反之right左移一位
    // 如果等于0，放到res中
  }
}
return res
```

**注意点: 双指针需要跳过重复情况**



## 16. Three Sum Cloest

> 方法: 双指针，hashset

做法同上，只是将target值换成了任意数

这里尝试使用hashset做，可能由于测试数据量较大，在hashset扩容的时候耗费较多时间导致同样是$O(n^2)$的复杂度，hashset却花费几倍多的时间。

**注意点: 同上**



## 17. Letter Combinations of a Phone Number

> 方法: 递归

常见递归题，将九宫格的数字对应的字母存放在一个数组中(["", "", "abc", "def", …])，之后使用StringBuffer递归循环当前数字对应的字母并存放。

本题为最基础的递归获取全排列类型题目，其他变种题目需要一些额外操作。



## 18. Four Sum

> 方法: 双指针，HashSet

解法同Three Sum

不同点在于剪枝操作。分两种情况讨论：

(1). 当 i < len-3 && nums[i]+nums[i+1]+nums[i+2]+nums[i+3] > target时，说明之后的i无论后面怎么选三个数都不能使其和等于target, 因此break结束。

(2). 当 nums[i]+nums[len-1]+nums[len-2]+nums[len-3] < target时，说明当前的i无论后面怎么选其和都小于target, 因此continue跳过。

**注意点: 在删去重复的时候需要分别判断i, j, left, right四个指针**



## 19. Remove Nth Node From End of List

> 方法: 快慢指针

题目描述为删除链表中倒数第n个节点。

做法为使用快慢双指针。先让快指针走n步，之后快慢指针一起走直到快指针到达末尾。之后慢指针所指向的节点就是删除的前一个节点，我们将它的next指向所需删除节点的next，这样就可以跳过第n个节点达到删除效果。

**注意点: 需要在链表前面加上头指针，因为有可能我们需要删除整个链表的第一个节点。**



## 20. Valid Parentheses

> 方法: Stack

Easy难度题目，大概率面试不会碰到。

题目描述：判断括号字符串是否有效。例: "{()}"输出true。

使用Stack存放所有类型的左括号，碰到右括号时判断：

(1). Stack是否为空，为空返回false。

(2). Stack pop出来的是否是对应的右括号，不是返回false。

遍历完成后，返回Stack是否为空，为空输出true，不为空输出false。

