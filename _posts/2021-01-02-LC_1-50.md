---
layout:     post
title:      LeetCode刷题总结（1～50）
subtitle:   记录LC二刷过程，持续更新
date:       2021-01-02
author:     Hanyu Chen
header-img: img/post-bg-debug.png
catalog: true
tags:
    - LeetCode
---

## 1. Two Sum

> 数据结构: HashMap

梦开始的地方。很常规的一道题，直接用HashMap将列表索引和值对应存起来。之后再遍历一次寻找两数。

**注意点：遍历寻找时要将自身排除**

## 15. Three Sum

> 方法: HashMap, 双指针

暴力解法 $O(n^3)$ ，有两种 $O(n^2)$ 解法：

解法一：将所有数两两相加，存在一个HashMap中，其中key为相加后的值，value为两数的列表（因为可能有很多种两数相加后等于同一个值）。之后再遍历一次寻找。时间$O(n^2)$，空间$O(n^2)$

解法二：双指针。详情见伪代码：
```java
for (int i = 0; i < len; ++i) {
  // 用三个变量存：curr(当前值)；left(curr后一个值)；right(列表最后一个值)
  // 如果当前值 > 0，直接break
  while (left < right) {
    // 如果curr+left+right < 0，left右移一位；反之right左移一位
    // 如果等于0，放到res中
  }
}
return res
```

**注意点: 双指针需要跳过重复情况**



## 16. Three Sum Cloest

> 方法: 双指针，hashset

做法同上，只是将target值换成了任意数

这里尝试使用hashset做，可能由于测试数据量较大，在hashset扩容的时候耗费较多时间导致同样是$O(n^2)$的复杂度，hashset却花费几倍多的时间。

**注意点: 同上**



## 17. Letter Combinations of a Phone Number

> 方法: 递归

常见递归题，将九宫格的数字对应的字母存放在一个数组中(["", "", "abc", "def", …])，之后使用StringBuffer递归循环当前数字对应的字母并存放。

本题为最基础的递归获取全排列类型题目，其他变种题目需要一些额外操作。



## 18. Four Sum

> 方法: 双指针，HashSet

解法同Three Sum

不同点在于剪枝操作。分两种情况讨论：

(1). 当 i < len-3 && nums[i]+nums[i+1]+nums[i+2]+nums[i+3] > target时，说明之后的i无论后面怎么选三个数都不能使其和等于target, 因此break结束。

(2). 当 nums[i]+nums[len-1]+nums[len-2]+nums[len-3] < target时，说明当前的i无论后面怎么选其和都小于target, 因此continue跳过。

**注意点: 在删去重复的时候需要分别判断i, j, left, right四个指针**



## 19. Remove Nth Node From End of List

> 方法: 快慢指针

题目描述为删除链表中倒数第n个节点。

做法为使用快慢双指针。先让快指针走n步，之后快慢指针一起走直到快指针到达末尾。之后慢指针所指向的节点就是删除的前一个节点，我们将它的next指向所需删除节点的next，这样就可以跳过第n个节点达到删除效果。

**注意点: 需要在链表前面加上头指针，因为有可能我们需要删除整个链表的第一个节点。**



## 20. Valid Parentheses

> 方法: Stack

Easy难度题目，大概率面试不会碰到。

题目描述：判断括号字符串是否有效。例: "{()}"输出true。

使用Stack存放所有类型的左括号，碰到右括号时判断：

(1). Stack是否为空，为空返回false。

(2). Stack pop出来的是否是对应的右括号，不是返回false。

遍历完成后，返回Stack是否为空，为空输出true，不为空输出false。



## 21. Merge Two Sorted Lists

> 方法: 迭代，递归

和MergeSort中merge操作类似，合并两个排序好的链表。

可以直接秒，注意用递归比迭代更快



## 22. Generate Parentheses

> 方法: 递归回溯

属于回溯类型题目的变种。

题目描述：输入总的括号对数，输出所有可能生成的括号种类

例：输入3，输出["((()))","(()())","(())()","()(())","()()()"]

解法详见伪代码：

``````java
// left表示剩余左括号个数，right表示剩余右括号个数
private void backtracking(int left, int right, sb, res) {
  // 如果left==0并且right==0，说明括号全部用完，将当前字符串放入res（递归出口）
  // 如果left==0，说明左括号用完，只能放右括号，之后进入下一步递归
  // 如果left==right，说明此时前面的括号都已经成对，只能放左括号，之后进入下一步递归
  // 分别放入左括号和右括号，进入下一步递归
}
``````

**注意点: 在每一次递归返回之后要删去字符串的最后一位**



## 23. Merge k Sorted Listes

> 方法: 优先队列，直接merge

最简单的方式就是对所有k个链表做k-1次merge，这里和两个链表merge方法相同。

使用PriorityQueue做更加巧妙。这里维护一个容量大小为k的优先队列（注意要重写compare函数），之后把列表内所有头节点加入优先队列中。最后使用一个while循环，当优先队列不是空的时候，poll堆顶部元素，并将poll出来的元素的next加入优先队列中。完成之后输出res。

**注意点: 在Override compare函数的时候需要先new一个comparator**



## 24. Swap Nodes in Pairs

题目描述：两个两个反转链表，如 1->2->3->4  =>  2->1->4->3

看起来比较简单的一道题，但链表类型的题目往往更加考察指针操作时的逻辑推理。

本题我们需要需要四个临时指针，以上面链表为例：

(1). 需要指针curr指向1

(2). 需要指针currNext指向2

(3). 需要new一个头指针currPrev表示前面一个pair的尾节点

(4). 需要tmpNext指向下一个pair的头节点

具体操作见以下伪代码：

```java
while (true) {
  tmpNext = currNext.next; //记录下一个pair的头节点
  curr.next = null; //当前节点指向null
  currNext.next = curr; //当前pair的第二个节点指向第一个节点
  currPrev.next = currNext; //前一个pair的尾节点指向当前pair转换后的头节点
  
  //-----------------以上代码为对当前pair进行反转操作-------------------
  
  currPrev = curr; //当前pair成为前一个pair，且curr变为前一个pair的尾节点
  curr = tmpNext; //下一个pair成为当前pair，且tmpNext变为当前pair的第一个节点
  
  if (tmpNext == null || tmpNext.next == null) break; //如果当前pair长度不足2，则break出循环
  
  currNext = tmpNext.next;//tmpNext.next变为当前pair的第二个节点
  
  //--------------以上代码为将下一个pair过渡到当前pair的操作--------------
  
}
currPrev.next = curr; //出循环后将前一个pair的尾节点指向当前pair
```



## 25. Reverse Nodes in k-Group

> 方法: 递归

很烦，又碰到hard题。

思路和上一题相似，这里我们尝试使用递归。在递归函数内，我们传入三个参数：前一个pair的尾节点，当前pair的头节点，k的值。

对于每一次递归，我们先判断剩余链表长度是否能达到k。

(1). 如果达不到，说明我们到达了递归出口，直接将前一个pair的尾节点指向当前pair的头节点之后输出即可。

(2). 如果达到了，那么我们需要先反转前k个节点，之后将前一个pair的尾节点指向当前pair反转之后的头节点，最后传入当前pair反转后的尾节点和下一个pair的头节点进入下一个递归。

**注意点: 这题一次过，没啥好注意的**

